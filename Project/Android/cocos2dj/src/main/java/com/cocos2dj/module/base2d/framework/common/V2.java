package com.cocos2dj.module.base2d.framework.common;

import com.badlogic.gdx.math.Vector2;

/*
* JBox2D - A Java Port of Erin Catto's Box2D
* 
* JBox2D homepage: http://jbox2d.sourceforge.net/
* Box2D homepage: http://www.box2d.org
* 
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/


/**
 * A 2D column vector
 */
public final class V2 {
	
	public static Vector2 stackVec2 = new Vector2();
	
	/**(x, y) <- (y, x)*/
	public static final void swap(Vector2 self){
		float temp = self.x;
		self.x = self.y;
		self.y = temp;
	}
	

	/** Flip the vector and return it - alters this vector. */
	public static final Vector2 negate(Vector2 self) {
		self.x = -self.x;
		self.y = -self.y;
		return self;
	}

	/** Normalize this vector and return the length before normalization.  Alters this vector. */
	public static final float normalize(Vector2 self) {
		
		final float length = self.len();
		if (length < Settings.EPSILON) {
			return 0f;
		}
		
		self.x /= length;
		self.y /= length;
		return length;
	}

	/** True if the vector represents a pair of valid, non-infinite floating point numbers. */
	public static final boolean isValid(Vector2 self) {
		return self.x != Float.NaN && self.x != Float.NEGATIVE_INFINITY
		&& self.x != Float.POSITIVE_INFINITY && self.y != Float.NaN
		&& self.y != Float.NEGATIVE_INFINITY && self.y != Float.POSITIVE_INFINITY;
	}


	/* djm created */
	public static final void abs(Vector2 self){
		self.x = MathUtils.abs(self.x);
		self.y = MathUtils.abs(self.y);
	}

	/** Return a copy of this vector. */
	public static final Vector2 clone(Vector2 self) {
		return new Vector2(self.x, self.y);
	}

	/*
	 * Static
	 */
	/* djm created */
	public final static void absToOut(Vector2 a, Vector2 out){
		out.x = MathUtils.abs( a.x);
		out.y = MathUtils.abs( a.y);
	}
	//public final static float dot(V2 a, V2 b) {
		//return a.x * b.x + a.y * b.y;
	//}
	//public final static float cross(V2 a, V2 b) {
		//return a.x * b.y - a.y * b.x;
	//}
	//public final static V2 cross(V2 a, float s) {
		//return new V2(s * a.y, -s * a.x);
	//}


	/* djm created */
	public final static void crossToOut(float s, Vector2 a, Vector2 out){
		float tempY = s * a.x;
		out.x = -s * a.y;
		out.y = tempY;
	}
	
	public final static void negateToOut(Vector2 a, Vector2 out){
		out.x = -a.x;
		out.y = -a.y;
	}

	//public final static V2 min(V2 a, V2 b) {
		//return new Vec2(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y);
	//}

	//public final static Vec2 max(Vec2 a, Vec2 b) {
		//return new Vec2(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y);
	//}

	/* djm created */
	public final static void minToOut(Vector2 a, Vector2 b, Vector2 out) {
		out.x = a.x < b.x ? a.x : b.x;
		out.y = a.y < b.y ? a.y : b.y;
	}

	/* djm created */
	public final static void maxToOut(Vector2 a, Vector2 b, Vector2 out) {
		out.x = a.x > b.x ? a.x : b.x;
		out.y = a.y > b.y ? a.y : b.y;
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
//	@Override
//	public boolean equals(Object obj) { //automatically generated by Eclipse
//		if (this == obj)
//			return true;
//		if (obj == null)
//			return false;
//		if (getClass() != obj.getClass())
//			return false;
//		V2 other = (V2) obj;
//		if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))
//			return false;
//		if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))
//			return false;
//		return true;
//	}
	

	/*************************************************************
	 * {x,y}(new)={x/length,y/length}
	 * @return V2(new)
	 */
	//public final V2 normalize(){
	/*************************************************************/
		//float length = length();
		//if(length==0)return new V2();
		//return new V2(x/length,y/length);
	//}
	
	/*************************************************************
	 * V2{x,y}(new)=V2{|x|,|y|}(this)
	 * @return V2(new)
	 */
	//public final V2 abs() {
	/*************************************************************/
		//return new V2(Math.abs(x), Math.abs(y));
	//}

	/*************************************************************
	 * V2{x,y}(this)=V2{|x|,|y|}(this)
	 * @return V2(this)
	 */

	
	
	/*************************************************************
	 * V2(new)=V2{|x|,|y|}(a)
	 * @param a
	 * @return V2(new)
	 */
	//public final static V2 abs(final V2 a) {
	/*************************************************************/
		//return new V2(Math.abs(a.x), Math.abs(a.y));
	//}

	/**
	 * dot={ax,ay}.{bx,by}=ax*bx+ay*by
	 * (V2(a).length*V2(b).length*cos(a^b))
	 * @param a
	 * @param b
	 * @return float(dot)
	 */
	public final static float dot(final Vector2 a, final Vector2 b) {
		return a.x * b.x + a.y * b.y;
	}

	/*************************************************************
	 * cross= {ax,ay,0}x{bx,by,0} = i*0+j*0+k*(ax*by-ay*bx)
	 * 	    = k*ax*by-ay*bx
	 * (V2(a).length*V2(b).length*sin(a^b))
	 * @param a
	 * @param b
	 * @return float (cross)
	 */
	public final static float cross(final Vector2 a, final Vector2 b) {
	/*************************************************************/
		return a.x * b.y - a.y * b.x;
	}

	/**
	 * V2(cross)={ax,ay,0}x{0,0,s}=i*s*ay+-j*s*ax+k*0
	 * 		={s*ay,-s*ax,0}
	 * V2(new)=V2{s*a.y,-s*a.x}
	 * @param a
	 * @param s
	 * @return V2(new)
	 */
	public final static Vector2 cross(final Vector2 a, final float s) {
		return new Vector2(s * a.y, -s * a.x);
	}
	
	public final static void crossToOut(final Vector2 a, final float s, final Vector2 out) {
		out.set(s * a.y, -s * a.x);
	}
	
	/*************************************************************
	 * V2(cross)={0,0,s}*{ax,ay,0}={-s*ay,s*ax,0}
	 * V2(new)=V2{-s*a.y,s*a.x}
	 * @param s
	 * @param a
	 * @return V2(new)
	 */
	public final static Vector2 cross(final float s, final Vector2 a) {
	/*************************************************************/
		return new Vector2(-s * a.y, s * a.x);
	}
	
	/*************************************************************
	 * V2(new)={min[ax,bx],min[ay,by]}
	 * @param a
	 * @param b
	 * @return V2()new
	 */
	public final static Vector2 min(final Vector2 a, final Vector2 b) {
	/*************************************************************/
		return new Vector2(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y);
	}

	/*************************************************************
	 * V2(new)={max[ax,bx],max[ay,by]}
	 * @param a
	 * @param b
	 * @return V2(new)
	 */
	public final static Vector2 max(final Vector2 a, final Vector2 b) {
	/*************************************************************/
		return new Vector2(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y);
	}
}
